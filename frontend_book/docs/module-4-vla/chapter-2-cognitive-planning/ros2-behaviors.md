---
sidebar_position: 4
title: "ROS 2 Behaviors"
description: "Mapping cognitive plans to executable ROS 2 behaviors and actions"
---

# ROS 2 Behaviors

## Introduction to Behavior-Based Robotics

Behavior-based robotics decomposes complex robotic tasks into modular, reusable behaviors that can be orchestrated to accomplish high-level goals. In the context of cognitive planning with LLMs, ROS 2 behaviors serve as the bridge between high-level plans generated by language models and low-level robot control. This approach enables flexible, robust, and maintainable robotic systems.

## The Role of Behaviors in Cognitive Planning

In cognitive planning systems, behaviors serve several key functions:

- **Plan Execution**: Converting plan steps into executable robot actions
- **Abstraction Layer**: Hiding low-level control complexity from high-level planners
- **Reusability**: Creating modular components that can be combined in various ways
- **Robustness**: Providing error handling and recovery within individual behaviors
- **Composition**: Allowing complex behaviors to be built from simpler ones

## ROS 2 Behavior Architecture

ROS 2 provides several architectural patterns for implementing behaviors:

### 1. Action-Based Behaviors

Actions are ideal for long-running behaviors with feedback:

```python
import rclpy
from rclpy.action import ActionServer, GoalResponse, CancelResponse
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor

# Example custom action for complex manipulation
from manipulation_msgs.action import ComplexManipulation

class ManipulationBehaviorServer(Node):
    def __init__(self):
        super().__init__('manipulation_behavior_server')

        # Create action server for complex manipulation
        self._action_server = ActionServer(
            self,
            ComplexManipulation,
            'complex_manipulation',
            self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback
        )

    def goal_callback(self, goal_request):
        """Accept or reject a goal request."""
        self.get_logger().info('Received manipulation goal request')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Accept or reject a client request to cancel an action."""
        self.get_logger().info('Received manipulation cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """Execute the manipulation goal."""
        self.get_logger().info('Executing manipulation goal')

        feedback_msg = ComplexManipulation.Feedback()
        result_msg = ComplexManipulation.Result()

        # Extract parameters from goal
        target_object = goal_handle.request.target_object
        grasp_type = goal_handle.request.grasp_type
        placement_location = goal_handle.request.placement_location

        # Execute the manipulation sequence
        steps = [
            ("approach_object", self.approach_object, [target_object]),
            ("grasp_object", self.grasp_object, [target_object, grasp_type]),
            ("lift_object", self.lift_object, [target_object]),
            ("transport_object", self.transport_object, [placement_location]),
            ("place_object", self.place_object, [placement_location])
        ]

        for i, (step_name, step_func, args) in enumerate(steps):
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result_msg.success = False
                result_msg.message = 'Goal canceled'
                return result_msg

            try:
                # Execute the step
                success = step_func(*args)

                if not success:
                    goal_handle.abort()
                    result_msg.success = False
                    result_msg.message = f'Step {step_name} failed'
                    return result_msg

                # Update feedback
                feedback_msg.current_step = step_name
                feedback_msg.progress = float(i + 1) / len(steps)
                goal_handle.publish_feedback(feedback_msg)

            except Exception as e:
                goal_handle.abort()
                result_msg.success = False
                result_msg.message = f'Step {step_name} failed with error: {str(e)}'
                return result_msg

        # Complete successfully
        goal_handle.succeed()
        result_msg.success = True
        result_msg.message = 'Manipulation completed successfully'
        return result_msg

    def approach_object(self, target_object):
        """Approach the target object."""
        # Implementation would use navigation or arm control
        self.get_logger().info(f'Approaching {target_object}')
        return True  # Simulated success

    def grasp_object(self, target_object, grasp_type):
        """Grasp the target object."""
        self.get_logger().info(f'Grasping {target_object} with {grasp_type} grasp')
        return True  # Simulated success

    def lift_object(self, target_object):
        """Lift the grasped object."""
        self.get_logger().info(f'Lifting {target_object}')
        return True  # Simulated success

    def transport_object(self, placement_location):
        """Transport object to placement location."""
        self.get_logger().info(f'Transporting to {placement_location}')
        return True  # Simulated success

    def place_object(self, placement_location):
        """Place the object at the location."""
        self.get_logger().info(f'Placing object at {placement_location}')
        return True  # Simulated success
```

### 2. Behavior Trees

Behavior trees provide a more sophisticated approach to behavior composition:

```python
# First, install the required package
# pip install py_trees

import py_trees
import py_trees_ros
import rclpy
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import String

class NavigationBehavior(py_trees.behaviour.Behaviour):
    def __init__(self, name, target_pose):
        super(NavigationBehavior, self).__init__(name)
        self.target_pose = target_pose
        self.nav_client = None

    def setup(self, **kwargs):
        """Setup the navigation client."""
        try:
            self.nav_client = kwargs['node'].nav_client
        except KeyError as e:
            error_message = f'No navigation client provided for {self.name}: {str(e)}'
            raise KeyError(error_message) from e

    def initialise(self):
        """Initialise the navigation goal."""
        self.logger.debug(f'{self.name} [NavigationBehavior::initialise]')

    def update(self):
        """Execute the navigation."""
        if not self.nav_client:
            self.feedback_message = "Navigation client not initialized"
            return py_trees.common.Status.FAILURE

        # Send navigation goal
        goal_msg = PoseStamped()
        goal_msg.header.frame_id = 'map'
        goal_msg.pose = self.target_pose

        # This would actually send the goal to navigation system
        # nav_future = self.nav_client.send_goal_async(goal_msg)

        self.feedback_message = f"Navigating to {self.target_pose}"
        return py_trees.common.Status.RUNNING  # or SUCCESS/FAILURE based on actual result

    def terminate(self, new_status):
        """Clean up when the behavior terminates."""
        self.logger.debug(f'{self.name} [NavigationBehavior::terminate->{new_status}]')

class ObjectDetectionBehavior(py_trees.behaviour.Behaviour):
    def __init__(self, name, object_type, search_area):
        super(ObjectDetectionBehavior, self).__init__(name)
        self.object_type = object_type
        self.search_area = search_area
        self.detector = None

    def setup(self, **kwargs):
        """Setup the object detector."""
        try:
            self.detector = kwargs['node'].object_detector
        except KeyError as e:
            error_message = f'No detector provided for {self.name}: {str(e)}'
            raise KeyError(error_message) from e

    def update(self):
        """Execute object detection."""
        if not self.detector:
            return py_trees.common.Status.FAILURE

        # Detect objects in the search area
        detected_objects = self.detector.detect_objects(
            self.object_type,
            self.search_area
        )

        if detected_objects:
            # Store detected object in blackboard for other behaviors
            py_trees.blackboard.Blackboard().set(
                f"detected_{self.object_type}",
                detected_objects[0]  # Store first detected object
            )
            self.feedback_message = f"Found {self.object_type}"
            return py_trees.common.Status.SUCCESS
        else:
            self.feedback_message = f"No {self.object_type} found"
            return py_trees.common.Status.FAILURE

def create_plan_execution_tree():
    """
    Create a behavior tree for executing a cognitive plan
    """
    # Create the root
    root = py_trees.composites.Sequence(name="PlanExecution", memory=True)

    # Create behaviors for a simple plan: navigate -> detect object -> pick up
    navigate_to_kitchen = NavigationBehavior(
        name="NavigateToKitchen",
        target_pose=[2.0, 1.0, 0.0]  # x, y, theta
    )

    detect_red_cup = ObjectDetectionBehavior(
        name="DetectRedCup",
        object_type="red_cup",
        search_area="kitchen_counter"
    )

    # Another behavior for picking up (would be implemented similarly)
    pick_up_object = py_trees.behaviours.Success(name="PickUpObject")  # Placeholder

    # Add behaviors to the sequence
    root.add_child(navigate_to_kitchen)
    root.add_child(detect_red_cup)
    root.add_child(pick_up_object)

    return root
```

### 3. State Machine Behaviors

State machines provide another approach for complex behaviors:

```python
from enum import Enum
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from std_msgs.msg import String

class NavigationState(Enum):
    IDLE = 1
    NAVIGATING = 2
    ADJUSTING = 3
    COMPLETE = 4
    FAILED = 5

class NavigationStateMachine(Node):
    def __init__(self):
        super().__init__('navigation_state_machine')

        # State management
        self.current_state = NavigationState.IDLE
        self.target_pose = None
        self.current_pose = None

        # Publishers and clients
        self.status_pub = self.create_publisher(String, 'navigation_status', 10)
        # Navigation action client would be initialized here

    def transition_to(self, new_state):
        """Handle state transitions."""
        old_state = self.current_state
        self.current_state = new_state
        self.get_logger().info(f'State transition: {old_state.name} -> {new_state.name}')

        # Publish state change
        status_msg = String()
        status_msg.data = f'navigating_state_change:{new_state.name}'
        self.status_pub.publish(status_msg)

        return True

    def execute_navigation(self, target_pose):
        """Execute navigation with state machine."""
        self.target_pose = target_pose
        self.transition_to(NavigationState.NAVIGATING)

        # Navigation loop
        while self.current_state in [NavigationState.NAVIGATING, NavigationState.ADJUSTING]:
            if self.current_state == NavigationState.NAVIGATING:
                result = self.execute_navigation_step()
                if result == 'complete':
                    self.transition_to(NavigationState.COMPLETE)
                elif result == 'obstacle':
                    self.transition_to(NavigationState.ADJUSTING)
                elif result == 'failed':
                    self.transition_to(NavigationState.FAILED)
                    break
            elif self.current_state == NavigationState.ADJUSTING:
                result = self.adjust_path()
                if result == 'success':
                    self.transition_to(NavigationState.NAVIGATING)
                elif result == 'failed':
                    self.transition_to(NavigationState.FAILED)
                    break

        return self.current_state == NavigationState.COMPLETE

    def execute_navigation_step(self):
        """Execute one step of navigation."""
        # This would interface with actual navigation system
        # For simulation, we'll return different results based on state
        import random
        outcomes = ['continue', 'complete', 'obstacle', 'failed']
        weights = [0.7, 0.1, 0.15, 0.05]  # Most common is to continue

        result = random.choices(outcomes, weights=weights)[0]
        return result

    def adjust_path(self):
        """Adjust navigation path when obstacle is detected."""
        # Implement path adjustment logic
        import random
        outcomes = ['success', 'failed']
        weights = [0.8, 0.2]

        result = random.choices(outcomes, weights=weights)[0]
        return result
```

## Mapping LLM Plans to Behaviors

The key challenge is connecting LLM-generated plans to executable behaviors:

```python
class PlanToBehaviorMapper:
    def __init__(self, behavior_registry):
        self.behavior_registry = behavior_registry
        self.action_client_factory = ActionClientFactory()

    def map_plan_to_behaviors(self, llm_plan):
        """
        Map an LLM-generated plan to executable ROS 2 behaviors
        """
        behavior_sequence = []

        for step in llm_plan.get('steps', []):
            behavior = self.create_behavior_for_step(step)
            if behavior:
                behavior_sequence.append(behavior)

        return behavior_sequence

    def create_behavior_for_step(self, step):
        """
        Create a behavior for a single plan step
        """
        action = step.get('action', '').lower()
        parameters = step.get('parameters', {})

        # Map common actions to behaviors
        action_to_behavior = {
            'navigate_to': self.create_navigation_behavior,
            'go_to': self.create_navigation_behavior,
            'move_to': self.create_navigation_behavior,
            'pick_up': self.create_manipulation_behavior,
            'grasp': self.create_manipulation_behavior,
            'place': self.create_manipulation_behavior,
            'detect_object': self.create_perception_behavior,
            'find': self.create_perception_behavior,
            'wait': self.create_wait_behavior,
            'report': self.create_report_behavior
        }

        if action in action_to_behavior:
            return action_to_behavior[action](parameters)
        else:
            # Try to use LLM to determine the appropriate behavior
            return self.infer_behavior_from_description(step)

    def create_navigation_behavior(self, parameters):
        """
        Create navigation behavior from parameters
        """
        target_location = parameters.get('location', parameters.get('target', 'unknown'))

        # Convert location to coordinates if needed
        coordinates = self.resolve_location_to_coordinates(target_location)

        if coordinates:
            return {
                'type': 'navigation',
                'target': coordinates,
                'behavior_class': 'NavigationBehavior',
                'parameters': {
                    'x': coordinates[0],
                    'y': coordinates[1],
                    'theta': coordinates[2] if len(coordinates) > 2 else 0.0
                }
            }
        else:
            return None

    def create_manipulation_behavior(self, parameters):
        """
        Create manipulation behavior from parameters
        """
        object_id = parameters.get('object_id', parameters.get('object', 'unknown'))
        action_type = parameters.get('action_type', 'grasp')

        return {
            'type': 'manipulation',
            'object': object_id,
            'action': action_type,
            'behavior_class': 'ManipulationBehavior',
            'parameters': parameters
        }

    def create_perception_behavior(self, parameters):
        """
        Create perception behavior from parameters
        """
        object_type = parameters.get('object_type', parameters.get('object', 'any'))
        search_area = parameters.get('search_area', 'current_view')

        return {
            'type': 'perception',
            'object_type': object_type,
            'search_area': search_area,
            'behavior_class': 'PerceptionBehavior',
            'parameters': parameters
        }

    def resolve_location_to_coordinates(self, location_name):
        """
        Resolve a location name to coordinates
        """
        # This would interface with a location mapping system
        location_map = {
            'kitchen': [2.0, 1.0, 0.0],
            'living_room': [0.0, 0.0, 0.0],
            'bedroom': [5.0, 3.0, 1.57],
            'office': [-2.0, 4.0, -1.57],
            'dining_room': [1.0, -2.0, 0.0]
        }

        return location_map.get(location_name.lower())
```

## Behavior Execution and Monitoring

Execute and monitor behaviors for plan execution:

```python
class BehaviorExecutor:
    def __init__(self, node):
        self.node = node
        self.active_behaviors = {}
        self.behavior_results = {}

    def execute_behavior_sequence(self, behavior_sequence, callback=None):
        """
        Execute a sequence of behaviors
        """
        results = []

        for i, behavior in enumerate(behavior_sequence):
            self.node.get_logger().info(f'Executing behavior {i+1}/{len(behavior_sequence)}: {behavior["type"]}')

            try:
                result = self.execute_single_behavior(behavior)
                results.append({
                    'behavior': behavior,
                    'result': result,
                    'success': result.get('success', False)
                })

                if not result.get('success', False):
                    self.node.get_logger().warn(f'Behavior {i+1} failed: {result.get("error", "Unknown error")}')
                    break

            except Exception as e:
                error_result = {
                    'success': False,
                    'error': str(e),
                    'behavior_index': i
                }
                results.append({
                    'behavior': behavior,
                    'result': error_result,
                    'success': False
                })
                break

        # Call completion callback if provided
        if callback:
            callback(results)

        return results

    def execute_single_behavior(self, behavior):
        """
        Execute a single behavior and return result
        """
        behavior_type = behavior['type']

        if behavior_type == 'navigation':
            return self.execute_navigation_behavior(behavior)
        elif behavior_type == 'manipulation':
            return self.execute_manipulation_behavior(behavior)
        elif behavior_type == 'perception':
            return self.execute_perception_behavior(behavior)
        else:
            return {
                'success': False,
                'error': f'Unknown behavior type: {behavior_type}'
            }

    def execute_navigation_behavior(self, behavior):
        """
        Execute navigation behavior
        """
        target = behavior['parameters']

        # Create and send navigation goal
        # This is a simplified example - in practice, you'd use the actual navigation system
        self.node.get_logger().info(f'Navigating to x={target["x"]}, y={target["y"]}, theta={target["theta"]}')

        # Simulate navigation (in real system, this would be async)
        import time
        time.sleep(1)  # Simulate navigation time

        # For this example, assume navigation succeeds
        return {
            'success': True,
            'message': 'Navigation completed successfully',
            'final_pose': target
        }

    def execute_manipulation_behavior(self, behavior):
        """
        Execute manipulation behavior
        """
        obj = behavior['object']
        action = behavior['action']

        self.node.get_logger().info(f'Performing {action} on {obj}')

        # Simulate manipulation
        import time
        time.sleep(2)  # Simulate manipulation time

        return {
            'success': True,
            'message': f'{action} on {obj} completed successfully'
        }

    def monitor_behavior_execution(self, behavior_id, timeout=60.0):
        """
        Monitor a behavior's execution status
        """
        start_time = time.time()

        while time.time() - start_time < timeout:
            status = self.get_behavior_status(behavior_id)

            if status in ['completed', 'failed', 'canceled']:
                return self.get_behavior_result(behavior_id)

            time.sleep(0.1)  # Check every 100ms

        # Timeout occurred
        self.cancel_behavior(behavior_id)
        return {
            'success': False,
            'error': 'Behavior execution timed out',
            'timeout': True
        }
```

## Error Handling and Recovery

Implement robust error handling for behavior execution:

```python
class BehaviorErrorRecovery:
    def __init__(self, executor):
        self.executor = executor
        self.recovery_strategies = {
            'navigation_failure': self.recover_navigation_failure,
            'manipulation_failure': self.recover_manipulation_failure,
            'perception_failure': self.recover_perception_failure,
            'timeout_failure': self.recover_timeout_failure
        }

    def handle_behavior_failure(self, failed_behavior, error_info):
        """
        Handle failure of a behavior and attempt recovery
        """
        failure_type = self.classify_failure(error_info)

        if failure_type in self.recovery_strategies:
            recovery_result = self.recovery_strategies[failure_type](failed_behavior, error_info)

            if recovery_result['success']:
                # Retry the failed behavior
                retry_result = self.executor.execute_single_behavior(failed_behavior)
                return retry_result
            else:
                return {
                    'success': False,
                    'error': f'Failed to recover from {failure_type}: {recovery_result.get("error", "Unknown recovery error")}',
                    'recovery_attempted': True
                }
        else:
            return {
                'success': False,
                'error': f'No recovery strategy for failure type: {failure_type}',
                'recovery_attempted': False
            }

    def classify_failure(self, error_info):
        """
        Classify the type of failure based on error information
        """
        error_msg = str(error_info.get('error', ''))

        if 'navigation' in error_msg.lower() or 'path' in error_msg.lower():
            return 'navigation_failure'
        elif 'manipulation' in error_msg.lower() or 'grasp' in error_msg.lower():
            return 'manipulation_failure'
        elif 'detect' in error_msg.lower() or 'perception' in error_msg.lower():
            return 'perception_failure'
        elif 'timeout' in error_msg.lower():
            return 'timeout_failure'
        else:
            return 'unknown_failure'

    def recover_navigation_failure(self, behavior, error_info):
        """
        Recovery strategy for navigation failures
        """
        # Try alternative navigation approaches
        strategies = [
            lambda: self.try_different_planner(behavior),
            lambda: self.navigate_to_alternative_location(behavior),
            lambda: self.request_human_assistance(behavior)
        ]

        for strategy in strategies:
            try:
                result = strategy()
                if result['success']:
                    return result
            except Exception:
                continue  # Try next strategy

        return {'success': False, 'error': 'All navigation recovery strategies failed'}

    def recover_manipulation_failure(self, behavior, error_info):
        """
        Recovery strategy for manipulation failures
        """
        # Try different grasp approaches
        current_grasp = behavior['parameters'].get('grasp_type', 'default')

        alternative_grasps = {
            'default': ['pinch', 'power'],
            'pinch': ['power', 'suction'],
            'power': ['pinch', 'suction'],
            'suction': ['pinch', 'power']
        }

        for grasp_type in alternative_grasps.get(current_grasp, []):
            try:
                behavior['parameters']['grasp_type'] = grasp_type
                result = self.executor.execute_single_behavior(behavior)
                if result['success']:
                    return result
            except Exception:
                continue

        return {'success': False, 'error': 'All manipulation recovery strategies failed'}

    def recover_perception_failure(self, behavior, error_info):
        """
        Recovery strategy for perception failures
        """
        # Try different sensing approaches
        strategies = [
            lambda: self.change_viewpoint(behavior),
            lambda: self.use_different_sensor(behavior),
            lambda: self.increase_sensor_time(behavior)
        ]

        for strategy in strategies:
            try:
                result = strategy()
                if result['success']:
                    return result
            except Exception:
                continue

        return {'success': False, 'error': 'All perception recovery strategies failed'}

    def recover_timeout_failure(self, behavior, error_info):
        """
        Recovery strategy for timeout failures
        """
        # Increase timeout and retry
        original_timeout = behavior['parameters'].get('timeout', 30.0)
        new_timeout = min(original_timeout * 2, 300.0)  # Max 5 minutes

        behavior['parameters']['timeout'] = new_timeout

        try:
            result = self.executor.execute_single_behavior(behavior)
            return result
        except Exception as e:
            return {'success': False, 'error': f'Timeout recovery failed: {str(e)}'}
```

## Integration Example: Complete Plan Execution System

Here's how all components work together:

```python
class CognitivePlanExecutionSystem:
    def __init__(self):
        rclpy.init()
        self.node = rclpy.create_node('cognitive_plan_execution')

        # Initialize components
        self.plan_mapper = PlanToBehaviorMapper({})
        self.behavior_executor = BehaviorExecutor(self.node)
        self.error_recovery = BehaviorErrorRecovery(self.behavior_executor)

        # Publishers for status updates
        self.status_publisher = self.node.create_publisher(String, 'plan_execution_status', 10)

        self.get_logger().info('Cognitive Plan Execution System initialized')

    def execute_cognitive_plan(self, llm_plan):
        """
        Execute a plan generated by an LLM
        """
        try:
            # 1. Map LLM plan to behaviors
            self.get_logger().info('Mapping LLM plan to executable behaviors')
            behavior_sequence = self.plan_mapper.map_plan_to_behaviors(llm_plan)

            if not behavior_sequence:
                raise ValueError('No behaviors could be generated from the plan')

            self.get_logger().info(f'Mapped to {len(behavior_sequence)} behaviors')

            # 2. Execute behavior sequence
            self.get_logger().info('Starting behavior execution')
            results = self.behavior_executor.execute_behavior_sequence(behavior_sequence)

            # 3. Check results and handle failures
            success = all(result['success'] for result in results)

            if success:
                self.get_logger().info('Plan executed successfully')
                self.publish_status('plan_execution_completed_successfully')
            else:
                # Handle failures with recovery
                failed_idx = next(i for i, r in enumerate(results) if not r['success'])
                failed_behavior = results[failed_idx]['behavior']
                error_info = results[failed_idx]['result']

                self.get_logger().warn(f'Plan failed at behavior {failed_idx + 1}: {error_info.get("error")}')

                # Attempt recovery
                recovery_result = self.error_recovery.handle_behavior_failure(failed_behavior, error_info)

                if recovery_result['success']:
                    self.get_logger().info('Recovery successful, continuing plan execution')
                    # Continue with remaining behaviors
                else:
                    self.get_logger().error(f'Plan execution failed permanently: {recovery_result.get("error")}')
                    self.publish_status('plan_execution_failed_permanently')

            return {
                'success': success,
                'results': results,
                'total_behaviors': len(behavior_sequence),
                'successful_behaviors': sum(1 for r in results if r['success'])
            }

        except Exception as e:
            self.get_logger().error(f'Plan execution error: {str(e)}')
            self.publish_status(f'plan_execution_error:{str(e)}')
            return {
                'success': False,
                'error': str(e)
            }

    def publish_status(self, message):
        """
        Publish execution status
        """
        msg = String()
        msg.data = message
        self.status_publisher.publish(msg)

    def get_logger(self):
        """
        Get the node's logger
        """
        return self.node.get_logger()

def main():
    """
    Example usage of the cognitive plan execution system
    """
    system = CognitivePlanExecutionSystem()

    # Example plan from LLM (in practice, this would come from your LLM planning system)
    example_plan = {
        "plan_id": "example_plan_001",
        "steps": [
            {
                "step_id": "step_1",
                "action": "navigate_to",
                "parameters": {
                    "location": "kitchen",
                    "x": 2.0,
                    "y": 1.0,
                    "theta": 0.0
                }
            },
            {
                "step_id": "step_2",
                "action": "detect_object",
                "parameters": {
                    "object_type": "red_cup",
                    "search_area": "counter"
                }
            },
            {
                "step_id": "step_3",
                "action": "pick_up",
                "parameters": {
                    "object_id": "red_cup_001",
                    "grasp_type": "pinch"
                }
            },
            {
                "step_id": "step_4",
                "action": "navigate_to",
                "parameters": {
                    "location": "living_room",
                    "x": 0.0,
                    "y": 0.0,
                    "theta": 0.0
                }
            },
            {
                "step_id": "step_5",
                "action": "place",
                "parameters": {
                    "location": "table",
                    "object_id": "red_cup_001"
                }
            }
        ]
    }

    # Execute the plan
    result = system.execute_cognitive_plan(example_plan)

    print(f"Plan execution result: {result}")

    # Shutdown
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Performance Considerations

When implementing behavior-based cognitive planning:

- **Modularity**: Keep behaviors focused and reusable
- **Error Handling**: Implement comprehensive error handling and recovery
- **Monitoring**: Provide visibility into plan execution progress
- **Timeouts**: Set appropriate timeouts for long-running behaviors
- **Resource Management**: Manage robot resources (battery, computation) during execution
- **Safety**: Ensure behaviors include safety checks and constraints

## Summary

In this section, we've covered:
- Different architectural patterns for ROS 2 behaviors (actions, behavior trees, state machines)
- Techniques for mapping LLM-generated plans to executable behaviors
- Approaches for executing and monitoring behavior sequences
- Strategies for error handling and recovery during plan execution
- Integration patterns for complete cognitive plan execution systems

This completes Chapter 2 on Cognitive Planning with LLMs. The next chapter will focus on the complete integration of all VLA components.